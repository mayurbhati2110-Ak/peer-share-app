<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Peer Share Stream</title>
  <style>
    body { font-family: 'Segoe UI', sans-serif; background: linear-gradient(135deg,#0d1117,#1b2735); color:#fff; margin:0; padding:20px; display:flex; flex-direction:column; align-items:center; }
    h2 { margin: 8px 0 14px 0; }
    .controls-row { display:flex; gap:8px; align-items:center; }
    input, button { padding:10px 12px; border-radius:8px; border:none; font-size:15px; outline:none; }
    input { width:220px; text-align:center; }
    button { background:#1e88e5; color:#fff; cursor:pointer; }
    button:disabled { background:#3a5d83; cursor:not-allowed; }
    #videos { display:flex; gap:16px; margin-top:18px; width:100%; justify-content:center; flex-wrap:wrap; }
    .video-wrapper { position:relative; }
    video { width: 360px; max-width: 42vw; border-radius:10px; background:#000; }
    .fullscreen-btn { position:absolute; bottom:8px; right:8px; background:rgba(0,0,0,0.5); color:#fff; border:none; padding:6px; border-radius:6px; cursor:pointer; }
    #status { margin-top:10px; color:#9fc5ff; min-height:18px; }
    #clients { margin-left:10px; color:#cfe8ff; font-size:13px; }
  </style>
</head>
<body>
  <h2>ðŸŽ¥ Peer Share Stream</h2>

  <div class="controls-row">
    <input id="room" placeholder="Enter Room ID (e.g. demo1)" />
    <button id="joinBtn">Join Room</button>
    <span id="clients"></span>
  </div>

  <div id="controls" style="display:none; margin-top:12px;">
    <button id="shareVideo">ðŸ“¹ Video</button>
    <button id="shareAudio">ðŸŽ¤ Audio</button>
    <button id="shareBoth">ðŸŽ¥ Both</button>
  </div>

  <div id="videos">
    <div class="video-wrapper">
      <video id="localVideo" autoplay muted playsinline></video>
      <button class="fullscreen-btn" onclick="toggleFullscreen('localVideo')">â¤¢</button>
    </div>
    <div class="video-wrapper">
      <video id="remoteVideo" autoplay playsinline></video>
      <button class="fullscreen-btn" onclick="toggleFullscreen('remoteVideo')">â¤¢</button>
    </div>
  </div>

  <div id="status"></div>

  <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
  <script>
    const socket = io();
    let pc = null;
    let localStream = null;
    let currentRoom = null;
    let isSharing = false;      // true when this peer started sharing
    const joinBtn = document.getElementById("joinBtn");
    const roomInput = document.getElementById("room");
    const controls = document.getElementById("controls");
    const localVideo = document.getElementById("localVideo");
    const remoteVideo = document.getElementById("remoteVideo");
    const statusDiv = document.getElementById("status");
    const clientsSpan = document.getElementById("clients");

    function log(msg) { console.log(msg); statusDiv.textContent = msg; }

    // Show controls after join (so users always see share buttons)
    joinBtn.onclick = () => {
      const room = roomInput.value.trim();
      if (!room) return alert("Enter room ID!");
      currentRoom = room;
      socket.emit("join-room", room);
      controls.style.display = "block"; // show share options immediately after join
      log("Joining room " + room + " ...");
    };

    // Update clients display
    socket.on("room-update", ({ clients }) => {
      const count = (clients && clients.length) || 0;
      clientsSpan.textContent = count > 0 ? `In room: ${count}` : "";
      log(`Room members: ${count}`);
      // If two clients are present, we mark ready but do not auto-offer.
      if (count === 2) {
        log("Peer available. You can click Share to start streaming.");
      }
    });

    socket.on("room-full", () => {
      alert("Room is full (max 2). Try another room.");
      log("Room full");
    });

    // When server says both are ready
    socket.on("ready", () => {
      log("Both participants present. Ready to connect.");
      // do not auto-create offer â€” wait until user clicks Share
      // If this peer was already sharing (reconnect), restart call
      if (isSharing && pc) {
        // optionally re-negotiate
        createAndSendOffer();
      }
    });

    // Create or return existing RTCPeerConnection (with cleanup)
    function ensurePeer() {
      if (pc) return pc;
      // Clean up any previous
      pc = new RTCPeerConnection({
        iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
      });

      pc.onicecandidate = (e) => {
        if (e.candidate && currentRoom) {
          socket.emit("ice-candidate", { roomId: currentRoom, candidate: e.candidate });
        }
      };

      pc.onconnectionstatechange = () => {
        log("Connection state: " + pc.connectionState);
        if (pc.connectionState === "failed" || pc.connectionState === "disconnected") {
          // keep the UI available for retry
          log("Disconnected. You may retry sharing.");
        }
      };

      pc.ontrack = (ev) => {
        remoteVideo.srcObject = ev.streams[0];
        log("Receiving remote stream");
      };

      return pc;
    }

    // Add local tracks (but do not play localVideo necessarily)
    async function addLocalTracks(constraints) {
      if (localStream) {
        // stop existing tracks and remove
        localStream.getTracks().forEach(t => t.stop());
        localStream = null;
      }
      localStream = await navigator.mediaDevices.getUserMedia(constraints);
      // show local preview but muted
      localVideo.srcObject = localStream;
      const connection = ensurePeer();
      localStream.getTracks().forEach(t => connection.addTrack(t, localStream));
    }

    // Called when user clicks share
    async function share(type) {
      if (!currentRoom) return alert("Join a room first.");
      const constraints = (type === "video") ? { video: true } :
                          (type === "audio") ? { audio: true } : { video: true, audio: true };

      try {
        await addLocalTracks(constraints);
        isSharing = true;
        // ensure peer exists and then create/send offer
        ensurePeer();
        await createAndSendOffer();
        log("Sharing started.");
      } catch (err) {
        console.error(err);
        alert("Unable to access camera/microphone. Check permissions.");
      }
    }

    async function createAndSendOffer() {
      if (!pc) ensurePeer();
      try {
        // create offer and send to other peer
        const offer = await pc.createOffer();
        await pc.setLocalDescription(offer);
        socket.emit("offer", { roomId: currentRoom, offer });
        log("Sent offer");
      } catch (err) {
        console.error("Offer error", err);
      }
    }

    // Incoming signaling
    socket.on("offer", async ({ offer, from }) => {
      log("Received offer");
      // if pc already exists and we are the sharer (initiator) we could have collision
      // we avoid collision by only responding with answer
      ensurePeer();
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(offer));
        const answer = await pc.createAnswer();
        await pc.setLocalDescription(answer);
        socket.emit("answer", { roomId: currentRoom, answer });
        log("Sent answer");
      } catch (err) {
        console.error("Error handling offer", err);
      }
    });

    socket.on("answer", async ({ answer }) => {
      log("Received answer");
      if (!pc) return;
      try {
        await pc.setRemoteDescription(new RTCSessionDescription(answer));
      } catch (err) {
        console.error("Error setting remote answer", err);
      }
    });

    socket.on("ice-candidate", async (candidate) => {
      if (!pc) return;
      try {
        await pc.addIceCandidate(new RTCIceCandidate(candidate));
      } catch (err) {
        console.warn("Failed to add ICE candidate", err);
      }
    });

    // Buttons
    document.getElementById("shareVideo").onclick = () => share("video");
    document.getElementById("shareAudio").onclick = () => share("audio");
    document.getElementById("shareBoth").onclick = () => share("both");

    // Rejoin automatically if socket reconnects (keeping the same room)
    socket.on("connect", () => {
      if (currentRoom) {
        socket.emit("join-room", currentRoom);
        log("Socket reconnected, re-joining room...");
      }
    });

    // Fullscreen helper
    function toggleFullscreen(id) {
      const v = document.getElementById(id);
      if (!v) return;
      if (document.fullscreenElement) document.exitFullscreen();
      else v.requestFullscreen();
    }
    window.toggleFullscreen = toggleFullscreen;
  </script>
</body>
</html>
